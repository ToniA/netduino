//---------------------------------------------------------------------------
//
// Copyright 2010 Stanislav "CW" Simicek
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//---------------------------------------------------------------------------
//
// Dallas/Maxim 1-Wire Master
//
// 1-Wire Communication Through Software
// http://www.maxim-ic.com/app-notes/index.mvp/id/126
//
// 1-Wire Search Algorithm
// http://www.maxim-ic.com/app-notes/index.mvp/id/187
//
// Understanding and Using Cyclic Redundancy Checks with Maxim iButton Products
// http://www.maxim-ic.com/app-notes/index.mvp/id/27
//

#include "CW_NETMF_OneWire.h"
#include "CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire.h"
#include <TinyCLR_Runtime.h>

using namespace CW::NETMF::Hardware;

/////////////////////////////////////////////////////////////////////////////
// 1-Wire Standard Mode Delays
//                                             Min   Rec   Max
  const UINT32 OneWire_Delay_A =   6;       //   5     6    15
//const UINT32 OneWire_Delay_B = -not used- //  59    64   n/a
  const UINT32 OneWire_Delay_C =  60;       //  60    60   120
  const UINT32 OneWire_Delay_D =  10;       //   8    10   n/a
  const UINT32 OneWire_Delay_E =   9;       //   5     9    12
  const UINT32 OneWire_Delay_F =  55;       //  50    55   n/a
//const UINT32 OneWire_Delay_G = -not used- //   0     0     0
  const UINT32 OneWire_Delay_H = 480;       // 480   480   640
  const UINT32 OneWire_Delay_I =  70;       //  63    70    78
  const UINT32 OneWire_Delay_J = 410;       // 410   410   n/a

/////////////////////////////////////////////////////////////////////////////
// 1-Wire Basic Signal Functions
//
// These functions require precise timing, they are called by their
// respective interop wrappers from blocks with disabled interrupts.
//
// The calculation of delays is based on measured performance of Release code
// generated by RealView compiler.
//
#ifndef __ARMCC_VERSION
  #error 1-Wire function timing must be adjusted for this compiler
#endif

static BOOL OneWire_Reset(UINT32 pin)
{
  // Pull bus down, wait                                                      // Timing and compensation
  CPU_GPIO_EnableOutputPin(pin, FALSE);                                       // ~3.8 us, LOW at ~2 us
  HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_H - 6);          // ~3.8 - 2 + 3.5 = 5.3 -> 6 us

  // Release bus, wait
  CPU_GPIO_EnableInputPin(pin, FALSE, NULL, GPIO_INT_NONE, RESISTOR_PULLUP);  // ~5.4 us, HIGH at ~3.5 us
  HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_I - 2);          // ~5.4 - 3.5 = 1.9 -> 2 us

  // Sample, wait
  BOOL result = !CPU_GPIO_GetPinState(pin);                                   // ~1.7 us
  HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_J - 2);
  return result;
}

// Write '1' and Read signals have the same waveform
static BOOL OneWire_WriteBit(UINT32 pin, BOOL value)
{
  BOOL result = TRUE;

  // Pull bus down
  CPU_GPIO_EnableOutputPin(pin, FALSE);                                       // ~3.8 us, LOW at ~2 us
  if(value)
  {
    // Write '1' or Read wait
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_A - 5);        // ~3.8 - 2 + 3.5 = 5.3 -> 5 us (A = 6 us!)

    // Release bus, wait
    CPU_GPIO_EnableInputPin(pin, FALSE, NULL, GPIO_INT_NONE, RESISTOR_PULLUP);// ~5.4 us, HIGH at ~3.5 us
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_E - 4);        // ~5.4 - 1.7/2 = 4.55 -> 4 us

    // Sample, wait
    result = CPU_GPIO_GetPinState(pin);                                       // ~1.7 us
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_F - 2);
  }
  else
  {
    // Write '0' wait
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_C - 4);        // ~3.8 - 2 + 3.3 - 1.8 = 3.3 -> 4 us

    // Release bus, wait
    CPU_GPIO_SetPinState(pin, TRUE);                                          // ~3.3 us, HIGH at ~1.8
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_D - 2);        // ~3.3 - 1.8 = 1.5 -> 2 us
  }
  return result;
}

inline static BOOL OneWire_ReadBit(UINT32 pin)
{
  return OneWire_WriteBit(pin, TRUE);
}

static UINT8 OneWire_ReadByte(UINT32 pin)
{
  UINT8 retVal = 0; 
  for(UINT8 bit = 1; bit != 0; bit <<= 1)
  {
    if(OneWire_ReadBit(pin))
    {
      retVal |= bit;
    }
  }
  return retVal;
}

static inline void OneWire_WriteByte(UINT32 pin, UINT8 value)
{
  for(UINT8 bit = 1; bit != 0; bit <<= 1)
  {
    OneWire_WriteBit(pin, (value & bit));
  }
}

/////////////////////////////////////////////////////////////////////////////
// Interop
//
// For more detailed description of the functionality, parameters,
// return values, exceptions etc. see XMLDoc comments in OneWire.cs
//

void OneWire::_ctor(CLR_RT_HeapBlock* pMngObj, UINT32 portId, HRESULT &hr)
{
  // Initialize fields
  pMngObj[Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::FIELD__pin].NumericByRef().u4 = GPIO_PIN_NONE;

  // TODO: Check pint input/output attributes

  if(!CPU_GPIO_ReservePin(portId, TRUE))
  {
    hr = CLR_E_PIN_UNAVAILABLE; // System.Exception
    return;
  }

  // Store pin to member variable
  pMngObj[Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::FIELD__pin].NumericByRef().u4 = portId;

  // The first rising edge can be interpreted by a slave as the end
  // of a Reset pulse. Delay for the required reset recovery time
  // to be sure that the real reset is interpreted correctly.
  GLOBAL_LOCK(irq);
  {
    CPU_GPIO_EnableOutputPin(portId, TRUE);
    HAL_Time_Sleep_MicroSeconds_InterruptEnabled(OneWire_Delay_H);
  }
}


INT8 OneWire::Reset(CLR_RT_HeapBlock* pMngObj, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    INT8 retVal = OneWire_Reset(pin);
    return retVal;
  }
}


INT32 OneWire::Read(CLR_RT_HeapBlock* pMngObj, CLR_RT_TypedArray_UINT8 buffer, INT32 index, INT32 count, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    for(INT32 endIndex = index + count; index < endIndex; index++)
    {
      buffer[index] = OneWire_ReadByte(pin);
    }
  }
  return count; // Always read
}


INT8 OneWire::ReadBit(CLR_RT_HeapBlock* pMngObj, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    INT8 retVal = OneWire_ReadBit(pin);
    return retVal;
  }
}


UINT8 OneWire::ReadByte(CLR_RT_HeapBlock* pMngObj, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    UINT8 retVal = OneWire_ReadByte(pin);
    return retVal;
  }
}


void OneWire::Write(CLR_RT_HeapBlock* pMngObj, CLR_RT_TypedArray_UINT8 buffer, INT32 index, INT32 count, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    for(INT32 endIndex = index + count; index < endIndex; index++)
    {
      OneWire_WriteByte(pin, buffer[index]);
    }
  }
}


void OneWire::WriteBit(CLR_RT_HeapBlock* pMngObj, INT8 value, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    OneWire_WriteBit(pin, value);
  }
}


void OneWire::WriteByte(CLR_RT_HeapBlock* pMngObj, UINT8 value, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  GLOBAL_LOCK(irq);
  {
    OneWire_WriteByte(pin, value);
  }
}


#define ONE_WIRE_SEARCH_FAILED      -1
#define ONE_WIRE_SEARCH_FINISHED     0

INT32 OneWire::Search(CLR_RT_HeapBlock* pMngObj, UINT8 command, CLR_RT_TypedArray_UINT8 pattern, INT32 deviation, INT32 index, HRESULT &hr)
{
  UINT32 pin = Get_pin(pMngObj);
  ASSERT(pin != GPIO_PIN_NONE);

  UINT8* bitPattern = &pattern.GetBuffer()[index];
  UINT8 bitMask = 1;

  INT32 searchResult = ONE_WIRE_SEARCH_FINISHED;

  // FIMXE: Clock only what necessary!
  GLOBAL_LOCK(irq);
  {
    // The search algorithm begins with the devices on the bus being reset
    if(!OneWire_Reset(pin))
    {
      return ONE_WIRE_SEARCH_FAILED;
    }
    // If this is successful then the search command is sent
    OneWire_WriteByte(pin, command);

    for(int bitIndex = 1; bitIndex < 65; bitIndex++)
    {
      BOOL bitA = OneWire_ReadBit(pin);
      BOOL bitC = OneWire_ReadBit(pin);  // Complement

      if(bitA && bitC)
      {
        searchResult = ONE_WIRE_SEARCH_FAILED;
        break;
      }
      if(bitA == bitC)  // Both bits are zero, collision
      {
        // Reuse bitA to determine search direction
        if(bitIndex < deviation)
        {
          // Pick the same direction as last time
          bitA = ((*bitPattern) & bitMask) != 0;
        }
        else
        {
          // If current bit == deviation, pick '1', otherwise pick default '0'
          bitA = (bitIndex == deviation);
        }
        if(!bitA)
        {
          searchResult = bitIndex;  // Return new deviation
        }
      }
      if(bitA)
      {
        (*bitPattern) |= bitMask;
      }
      else
      {
        (*bitPattern) &= ~bitMask;
      }
      // Send the selected bit to the bus.
      OneWire_WriteBit(pin, bitA);

      if(!(bitMask <<= 1))
      {
        bitMask = 1;  // TODO: ++bitMask (?)
        bitPattern++;
      }
    }
    if(searchResult >= 0)
    {
      if(ComputeCRC(pattern, index, 8, 0, hr))
      {
        searchResult = ONE_WIRE_SEARCH_FAILED;  // Invalid ROM ID (CRC failed)
      }
    }
  } // GLOBAL_LOCK()
  return searchResult;
}


// Computes 8-bit CRC using x^8 + x^5 + x^4 + 1 polynomial
UINT8 OneWire::ComputeCRC(CLR_RT_TypedArray_UINT8 buffer, INT32 index, INT32 count, UINT8 crc, HRESULT &hr)
{
  // FIXME: Decrement index
  for(INT32 endIndex = index + count; index < endIndex; index++)
  {
    UINT8 b = buffer[index];
    for(int bit = 0; bit < 8; bit++)
    {
      int feedbackBit = (crc ^ b) & 1;
      crc >>= 1;
      if(feedbackBit)
      {
        crc ^= 0x8C;  // 0x31 reversed
      }
      b >>= 1;
    }
  }
  return crc;
}


// Computes 16-bit CRC using x^16 + x^15 + x^2 + 1 polynomial
UINT16 OneWire::ComputeCRC16(CLR_RT_TypedArray_UINT8 buffer, INT32 index, INT32 count, UINT16 crc, HRESULT &hr)
{
  // FIXME: Decrement index
  for(INT32 endIndex = index + count; index < endIndex; index++)
  {
    UINT8 b = buffer[index];
    for(int bit = 0; bit < 8; bit++)
    {
      int feedbackBit = (crc ^ b) & 1;
      crc >>= 1;
      if(feedbackBit)
      {
        crc ^= 0xA001;  // 0x8005 reversed
      }
      b >>= 1;
    }
  }
  return crc;
}
